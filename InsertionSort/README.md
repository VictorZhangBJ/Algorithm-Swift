# Insertion Sort


---

目标：将数组内的数据按从小到大的顺序排列起来。

插入排序来实现的步骤如下

- 把数据放到数组A中，现在数组中数据是无序的
- 从数组中取出一个数据，这个数据可以是任意的，不过为了方便和效率，我们一般从数组尾部取出数据
- 把这个数插入到一个新数组B中去
- 从未排序的数组A中再取出一个数，按照从小到大的顺序插入到B数组中去
- 再一次从未排序的数组A中取出一个数，按照大小顺序插入到B数组中去
- 重复上述步骤直到未排序的数组中元素为空位置，此时B数组为从小到大拍好序的数组

#实例

---
假设未排序的数组为`[8,3,5,4,6]`.

取出第一个数`6`,把他插入到一个新的数组中去，新的排序好的数组为`[6]`,未排序的数组为`[8,3,5,4]`

从未排序数组取出第二个数`4`，将它插入到排序好的新数组中去，它应该在`6`前面的位置，插入后新数组为`[4,6]`,未排序的数组为`[8,3,5]`

从未排序数组中取出第三个数`5`,将它按照顺序插入到排序好的数组中去，`5`应该在`4`和`6`之间，插入后排序好的数组为`[4,5,6]`,未排序的数组为`[8,3]`

重复上述步骤直到未排序的数组为空

#In-Place Sort
原地插入排序

上面介绍的方法需要两个数组来实现，浪费了资源，其实可以用一个数组来实现插入排序的效果，你只需在一个数组中标记出哪个部分是已排序的，哪个部分是未排序的即可。

一开始数组中元素为`[8,3,5,4,6]`,用`|`分割 排序部分和为未排序部分，`|`左边为排序部分，右边为未排序部分

`[| 8,3,5,4,6]`

现在排序部分为空，未排序部分从`8`开始

现在处理第一个数据`8`,处理后如下

`[8,| 3,5,4,6]`

处理完第一个数后，排序部分为`[8]`,未排序部分为`[3,5,4,6]`, `|` 标志向右移动一位。

下面就是排序的过程

```
[8, | 3,5,4,6]
[3,8, | 5,4,6]
[3,5,8, | 4,6]
[3,4,5,8, | 6]
[3,4,5,6,8, |]
```

#插入方法

---
每次插入，你从未排序部分的尾部取出一个数据，然后插入到排序部分中去。你必须插入到排序部分中的正确位置以保证插入后数组还是正确的顺序。怎么找到这个位置呢？

假如我们现在已经走了两步，现在数组如下所示
```
[3,5,8, | 4,6]
```
下一个取出的数是`4`,现在要把他插入到`[3,5,8]`中去，下面是一种方法，比较一下前一个数据`8`是否比`4`大？ Yes，将`4`和`8`位置互换一下

```
[3, 5, 8, 4, | 6]
     ^    

[3, 5, 4, 8, | 6]
       <-->
       swaped
```

现在继续比较`4`前面的数据`5`,是否比`4`大？Yes，继续交换两个数据的位置。

```
[3, 4, 5, 8, |6]
    <-->
    swapped
```

继续比较`4`前面的数据`3`,是否比`4`大？No，不交换位置；现在已经把排序部分所有元素比较完了，并且已经把`4`插入了正确的位置保证其顺序为从小到大。

这是一个数据插入 排序部分的过程，下面是代码实现

#代码
---

```

func insertionSort(array: [Int]) -> [Int] {
    var a = array
    for index in 1...a.count - 1 {
        var j = index
        while j >= 1{
            if a[j] < a[j-1] {
                swap(&a[j-1], &a[j])
            }
            j -= 1
        }
    }
    return a
}
```

放一个数组测试一下

```
var arr2 = [3,4,0,10,11,13,10,8,7,2,18]
insertionSort(array: arr2)
```

输出结果为

```
[0, 2, 3, 4, 7, 8, 10, 10, 11, 13, 18]
```

#移除Swap
---
上面的插入排序方法实现的效果很好，不过我们可以移除Swap操作，使排序更快一些。
在上面的排序过程中，我们一般是交换两个元素的位置来把他们放入合适的位置

```
[3, 5, 8, 4,| 6]
       <-->
       swap
[3, 5, 4, 8,| 6]
    <-->
    swap
```

我们可以先将取出的元素暂存起来，然后将符合要求的元素右移而不是每次都交换，这样可以节省操作，到最后再把取出的元素插入到合适的位置

```
[3, 5, 8, 4, | 6]       remember 4
          * 
[3, 5, 8, 8, | 6]       8右移一位
       --->
[3, 5, 5, 8, | 6]       5右移一位
    --->
[3, 4, 5, 8, | 6]       把4放到空余的位置
    *
```

代码如下

```
func insertionSort2(array: [Int]) -> [Int] {
    var a = array
    for index in 1...a.count - 1 {
        var j = index
        let temp = a[j]
        while (j > 0 && temp < a[j-1]){
            a[j] = a[j-1]
            j -= 1
        }
        a[j] = temp
    }
    return a
}
```

#通用排序

现在的排序算法只是针对Int型数据的，我们可以把他设计成泛型的，即适用于其他类型(包括对象类型)的排序，只需对象提供compare的闭包方法即可。

函数原型如下所示:

```
func insertionSort<T>(array: [T], _ isOrderedBefore:(T, T) -> Bool) ->[T] {}
```
数组里存储的是T类型的数据，T就是泛型的占位符；现在insertionSort能够接收任意类型的数组作为参数，即数组里可以存储Number、字符串或者其他类型的元素。

函数当中新的参数`_ isOrderedBefore:(T, T) -> Bool` 本身是一个闭包函数，这个函数接收两个T类型的参数，返回值为Bool类型；这个函数满足条件为：如果第一个T类型的对象按照对象本身的排序方法排在第二个T类型对象的前面则返回true，否则返回false。
swift的内置sort()函数的参数也是这样的。
改写insertionSort函数只需修改一下判断条件即可

```
while(j > 0 && temp < a[j-1])           改为  
while(j > 0 && isOrderdBefore(temp, a[j-1]))
```

`isOrderedBefore()`函数其实跟`temp < a[j-1]`实现的效果是一样的，只是我们把适用范围扩大到了更多数据类型，包括Numbers、字符串或一般的对象类型。

```
let numbers = [8,3,5,4,6,1,10]
insertionSort(array: numbers) { (t1, t2) -> Bool in
    return t1 < t2
}
```
属性swift闭包的同学应该知道还有一种更简便的写法
```
insertionSort(array: numbers, <)
```

上面是按从小到大的顺序排列，如果从大到小，只需将`<`改为`>`即可

```
insertionSort(array: numbers, >)
```
当然你还可以排序`string`类型的数组

```
let strings = ["blue", "red", "green", "white", "purple"]
insertionSort(array: strings, < )
```

甚至一般对象类型的数组也能排序，只需提供排序原则即可，比如按照对象的某个属性的大小排序,加入一个数组装的元素类型为Person类型的，我们按照其age属性来排序，代码如下所示：

```
let persons = [pserson1, person2, person3]
insertiontSort(array: objects) { $1.age < $2.age }
```

#性能表现
---
对于已经排好的数组来说，插入排序的速度非常快。这听起来像是一句废话，其实不尽然，尤其是在查找算法中。在实际情况中有些数据量会非常的庞大，大多数情况下排序再查找的效率一般是最高的。

插入排序的时间复杂度为**O(n^2)**.因为排序算法有两个嵌套的循环，其他的一些算法比如**快速排序**
以及**归并排序**的时间复杂度为**O(n log n)**, 他们在一些输入量很大的情况下有比较好的效率表现。

在排序小数组的时候，插入排序有着良好的效率表现。测试中得出，在超过100个数值以后，插入排序的性能开始落后于快速排序，数值量越多，差异越大。



